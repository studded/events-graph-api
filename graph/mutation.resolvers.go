package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.47

import (
	"context"
	"errors"

	"github.com/studded/events-graph-api/graph/model"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUser) (*model.User, error) {
	user := &model.User{
		Name:  input.Name,
		Email: input.Email,
		Phone: input.Phone,
	}

	return r.UsersRepo.CreateUser(user)
}

// CreateEvent is the resolver for the createEvent field.
func (r *mutationResolver) CreateEvent(ctx context.Context, input model.NewEvent, currentUserID int) (*model.Event, error) {
	event := &model.Event{
		Name:        input.Name,
		StartDate:   input.StartDate,
		EndDate:     input.EndDate,
		Location:    input.Location,
		Description: input.Description,
	}
	event, err := r.EventsRepo.CreateEvent(event)

	if err != nil {
		return event, err
	}

	// create a default admin role for the current user
	admin := &model.Role{
		EventID: event.ID,
		UserID:  currentUserID,
		Type:    "admin",
	}
	admin, err = r.RolesRepo.CreateRole(admin)

	return event, err
}

// CreateActivity is the resolver for the createActivity field.
func (r *mutationResolver) CreateActivity(ctx context.Context, input model.NewActivity, currentUserID int) (*model.Activity, error) {
	role, err := r.RolesRepo.GetRoleByEventIDAndUserID(input.EventID, currentUserID)

	if err != nil {
		return nil, err
	}

	if role.Type != "admin" && role.Type != "contributor" {
		return nil, errors.New("only admin and contributor may create activities")
	}

	activity := &model.Activity{
		EventID:     input.EventID,
		Name:        input.Name,
		StartTime:   input.StartTime,
		EndTime:     input.EndTime,
		Description: input.Description,
	}

	return r.ActivitiesRepo.CreateActivity(activity)
}

// CreateRole is the resolver for the createRole field.
func (r *mutationResolver) CreateRole(ctx context.Context, input model.NewRole, currentUserID int) (*model.Role, error) {
	// Check the current user has an admin/contributor role for the event
	role, err := r.RolesRepo.GetRoleByEventIDAndUserID(input.EventID, currentUserID)
	if err != nil || role.Type == "attendee" {
		return nil, errors.New("only admin/contributors may create roles")
	}

	// Contributor can only make attendee roles
	if role.Type == "contributor" && input.Type != "attendee" {
		return nil, errors.New("contributors can only create attendee roles")
	}

	// Else an admin can make any role...

	// Check user exists
	user, err := r.UsersRepo.GetUserByID(input.UserID)
	if err != nil {
		return nil, errors.New("user does not exist")
	}

	// Check event exists
	event, err := r.EventsRepo.GetEventByID(input.EventID)
	if err != nil {
		return nil, errors.New("event does not exist")
	}

	newRole := &model.Role{
		UserID:  user.ID,
		EventID: event.ID,
		Type:    input.Type,
	}

	return r.RolesRepo.CreateRole(newRole)
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
