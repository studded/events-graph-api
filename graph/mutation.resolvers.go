package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.47

import (
	"context"
	"errors"

	"github.com/studded/events-graph-api/graph/model"
	"github.com/studded/events-graph-api/middleware"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUser) (*model.User, error) {
	user := &model.User{
		Name:  input.Name,
		Email: input.Email,
		Phone: input.Phone,
	}

	return r.UsersRepo.CreateUser(user)
}

// CreateEvent is the resolver for the createEvent field.
func (r *mutationResolver) CreateEvent(ctx context.Context, input model.NewEvent) (*model.Event, error) {
	currentUser, err := middleware.GetCurrentUserFromCTX(ctx)

	if err != nil {
		return nil, errors.New("must be logged in to create events")
	}

	event := &model.Event{
		Name:        input.Name,
		StartDate:   input.StartDate,
		EndDate:     input.EndDate,
		Location:    input.Location,
		Description: input.Description,
	}
	event, err = r.EventsRepo.CreateEvent(event)

	if err != nil {
		return event, err
	}

	// create a default admin role for the current user
	admin := &model.Role{
		EventID: event.ID,
		UserID:  currentUser.ID,
		Type:    "admin",
	}
	admin, err = r.RolesRepo.CreateRole(admin)

	return event, err
}

// UpdateEvent is the resolver for the updateEvent field.
func (r *mutationResolver) UpdateEvent(ctx context.Context, id int, input model.UpdateEvent) (*model.Event, error) {
	currentUser, err := middleware.GetCurrentUserFromCTX(ctx)

	if err != nil {
		return nil, errors.New("must be logged in to update events")
	}

	// Check the current user has an admin role for the event
	role, err := r.RolesRepo.GetRoleByEventIDAndUserID(id, currentUser.ID)
	if err != nil || role.Type != "admin" {
		return nil, errors.New("only admins may update events")
	}

	event, err := r.EventsRepo.GetEventByID(id)

	if err != nil {
		return nil, err
	}

	if input.Name != nil {
		event.Name = *input.Name
	}

	if input.StartDate != nil {
		event.StartDate = *input.StartDate
	}

	if input.EndDate != nil {
		event.EndDate = *input.EndDate
	}

	if input.Location != nil {
		event.Location = *input.Location
	}

	if input.Description != nil {
		event.Description = *input.Description
	}

	return r.EventsRepo.UpdateEvent(event)
}

// DeleteEvent is the resolver for the deleteEvent field.
func (r *mutationResolver) DeleteEvent(ctx context.Context, id int) (bool, error) {
	currentUser, err := middleware.GetCurrentUserFromCTX(ctx)

	if err != nil {
		return false, errors.New("must be logged in to delete events")
	}

	// Check the current user has an admin role for the event
	role, err := r.RolesRepo.GetRoleByEventIDAndUserID(id, currentUser.ID)
	if err != nil || role.Type != "admin" {
		return false, errors.New("only admins may delete events")
	}

	// Check event exists
	event, err := r.EventsRepo.GetEventByID(id)
	if err != nil {
		return false, err
	}

	err = r.EventsRepo.DeleteEvent(event)

	if err != nil {
		return false, err
	}

	return true, nil
}

// CreateActivity is the resolver for the createActivity field.
func (r *mutationResolver) CreateActivity(ctx context.Context, input model.NewActivity) (*model.Activity, error) {
	currentUser, err := middleware.GetCurrentUserFromCTX(ctx)

	if err != nil {
		return nil, errors.New("must be logged in to create activities")
	}

	// Check the current user has an admin or contributor role for the event
	role, err := r.RolesRepo.GetRoleByEventIDAndUserID(input.EventID, currentUser.ID)
	if err != nil || role.Type != "admin" && role.Type != "contributor" {
		return nil, errors.New("only admins and contributors may create activities")
	}

	// Check event exists
	event, err := r.EventsRepo.GetEventByID(input.EventID)
	if err != nil {
		return nil, errors.New("event does not exist")
	}

	activity := &model.Activity{
		EventID:     event.ID,
		Name:        input.Name,
		StartTime:   input.StartTime,
		EndTime:     input.EndTime,
		Description: input.Description,
	}

	return r.ActivitiesRepo.CreateActivity(activity)
}

// UpdateActivity is the resolver for the updateActivity field.
func (r *mutationResolver) UpdateActivity(ctx context.Context, id int, input model.UpdateActivity) (*model.Activity, error) {
	currentUser, err := middleware.GetCurrentUserFromCTX(ctx)

	if err != nil {
		return nil, errors.New("must be logged in to update activities")
	}

	activity, err := r.ActivitiesRepo.GetActivityByID(id)
	if err != nil {
		return nil, err
	}

	// Check the current user has an admin or contributor role for the event
	role, err := r.RolesRepo.GetRoleByEventIDAndUserID(activity.EventID, currentUser.ID)
	if err != nil || role.Type != "admin" && role.Type != "contributor" {
		return nil, errors.New("only admins and contributors may update activites")
	}

	if input.Name != nil {
		activity.Name = *input.Name
	}

	if input.StartTime != nil {
		activity.StartTime = *input.StartTime
	}

	if input.EndTime != nil {
		activity.EndTime = *input.EndTime
	}

	if input.Description != nil {
		activity.Description = *input.Description
	}

	return r.ActivitiesRepo.UpdateActivity(activity)
}

// DeleteActivity is the resolver for the deleteActivity field.
func (r *mutationResolver) DeleteActivity(ctx context.Context, id int) (bool, error) {
	currentUser, err := middleware.GetCurrentUserFromCTX(ctx)

	if err != nil {
		return false, errors.New("must be logged in to delete activities")
	}

	activity, err := r.ActivitiesRepo.GetActivityByID(id)
	if err != nil {
		return false, err
	}

	// Check the current user has an admin or contributor role for the event
	role, err := r.RolesRepo.GetRoleByEventIDAndUserID(activity.EventID, currentUser.ID)
	if err != nil || role.Type != "admin" && role.Type != "contributor" {
		return false, errors.New("only admins and contributors may delete activities")
	}

	err = r.ActivitiesRepo.DeleteActivity(activity)

	if err != nil {
		return false, err
	}

	return true, nil
}

// CreateRole is the resolver for the createRole field.
func (r *mutationResolver) CreateRole(ctx context.Context, input model.NewRole) (*model.Role, error) {
	currentUser, err := middleware.GetCurrentUserFromCTX(ctx)

	if err != nil {
		return nil, errors.New("must be logged in to create roles")
	}

	// Check the current user has an admin/contributor role for the event
	role, err := r.RolesRepo.GetRoleByEventIDAndUserID(input.EventID, currentUser.ID)
	if err != nil || role.Type != "admin" && role.Type != "contributor" {
		return nil, errors.New("only admins and contributors may create roles")
	}

	// Contributor can only make attendee roles
	if role.Type == "contributor" && input.Type != "attendee" {
		return nil, errors.New("contributors may only create attendee roles")
	}

	// Check user exists
	user, err := r.UsersRepo.GetUserByID(input.UserID)
	if err != nil {
		return nil, errors.New("user does not exist")
	}

	// Check event exists
	event, err := r.EventsRepo.GetEventByID(input.EventID)
	if err != nil {
		return nil, errors.New("event does not exist")
	}

	newRole := &model.Role{
		UserID:  user.ID,
		EventID: event.ID,
		Type:    input.Type,
	}

	return r.RolesRepo.CreateRole(newRole)
}

// UpdateRole is the resolver for the updateRole field.
func (r *mutationResolver) UpdateRole(ctx context.Context, id int, input model.UpdateRole) (*model.Role, error) {
	currentUser, err := middleware.GetCurrentUserFromCTX(ctx)

	if err != nil {
		return nil, errors.New("must be logged in to update roles")
	}

	role, err := r.RolesRepo.GetRoleByID(id)
	if err != nil {
		return nil, err
	}

	// Check the current user has an admin role for the event
	roleCheck, err := r.RolesRepo.GetRoleByEventIDAndUserID(role.EventID, currentUser.ID)
	if err != nil || roleCheck.Type != "admin" {
		return nil, errors.New("only admins may update roles")
	}

	if input.Type != nil {
		role.Type = *input.Type
	}

	return r.RolesRepo.UpdateRole(role)
}

// DeleteRole is the resolver for the deleteRole field.
func (r *mutationResolver) DeleteRole(ctx context.Context, id int) (bool, error) {
	currentUser, err := middleware.GetCurrentUserFromCTX(ctx)

	if err != nil {
		return false, errors.New("must be logged in to create roles")
	}

	role, err := r.RolesRepo.GetRoleByID(id)
	if err != nil {
		return false, err
	}

	// Check the current user has an admin role for the event
	roleCheck, err := r.RolesRepo.GetRoleByEventIDAndUserID(role.EventID, currentUser.ID)
	if err != nil || roleCheck.Type != "admin" {
		return false, errors.New("only admins may delete roles")
	}

	err = r.RolesRepo.DeleteRole(role)

	if err != nil {
		return false, err
	}

	return true, nil
}

// CreateExpense is the resolver for the createExpense field.
func (r *mutationResolver) CreateExpense(ctx context.Context, input model.NewExpense) (*model.Expense, error) {
	currentUser, err := middleware.GetCurrentUserFromCTX(ctx)

	if err != nil {
		return nil, errors.New("must be logged in to create expenses")
	}

	// Check the current user has an admin role for the event
	role, err := r.RolesRepo.GetRoleByEventIDAndUserID(input.EventID, currentUser.ID)
	if err != nil || role.Type != "admin" {
		return nil, errors.New("only admins may create expenses")
	}

	// Check event exists
	event, err := r.EventsRepo.GetEventByID(input.EventID)
	if err != nil {
		return nil, errors.New("event does not exist")
	}

	expense := &model.Expense{
		EventID:     event.ID,
		Name:        input.Name,
		Cost:        input.Cost,
		Description: input.Description,
		Category:    input.Category,
	}

	return r.ExpensesRepo.CreateExpense(expense)
}

// UpdateExpense is the resolver for the updateExpense field.
func (r *mutationResolver) UpdateExpense(ctx context.Context, id int, input model.UpdateExpense) (*model.Expense, error) {
	currentUser, err := middleware.GetCurrentUserFromCTX(ctx)

	if err != nil {
		return nil, errors.New("must be logged in to update roles")
	}

	expense, err := r.ExpensesRepo.GetExpenseByID(id)
	if err != nil {
		return nil, err
	}

	// Check the current user has an admin role for the event
	role, err := r.RolesRepo.GetRoleByEventIDAndUserID(expense.EventID, currentUser.ID)
	if err != nil || role.Type != "admin" {
		return nil, errors.New("only admins may update expenses")
	}

	if input.Name != nil {
		expense.Name = *input.Name
	}

	if input.Cost != nil {
		expense.Cost = *input.Cost
	}

	if input.Description != nil {
		expense.Description = *input.Description
	}

	if input.Category != nil {
		expense.Category = *input.Category
	}

	return r.ExpensesRepo.UpdateExpense(expense)
}

// DeleteExpense is the resolver for the deleteExpense field.
func (r *mutationResolver) DeleteExpense(ctx context.Context, id int) (bool, error) {
	currentUser, err := middleware.GetCurrentUserFromCTX(ctx)

	if err != nil {
		return false, errors.New("must be logged in to delete roles")
	}

	expense, err := r.ExpensesRepo.GetExpenseByID(id)
	if err != nil {
		return false, err
	}

	// Check the current user has an admin role for the event
	role, err := r.RolesRepo.GetRoleByEventIDAndUserID(expense.EventID, currentUser.ID)
	if err != nil || role.Type != "admin" {
		return false, errors.New("only admins may delete expenses")
	}

	err = r.ExpensesRepo.DeleteExpense(expense)

	if err != nil {
		return false, err
	}

	return true, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
